# STM32 Bootloader串口指令快速测试手册

## 🎯 测试环境设置

### 硬件连接
- **MCU**: STM32F103C8T6
- **串口**: UART1 (PA9-TX, PA10-RX)
- **波特率**: 115200
- **数据位**: 8
- **停止位**: 1
- **校验位**: 无

### 内存布局
- **Bootloader**: 0x08000000-0x08003FFF (16KB)
- **Application**: 0x08004000-0x0800FFFF (48KB)

## 📋 协议格式

```
+--------+--------+--------+--------+--------+--------+--------+--------+
| HEADER | LENGTH |  TYPE  | STATUS |   DATA (0-252 bytes)   | CHECKSUM |
+--------+--------+--------+--------+--------+--------+--------+--------+
```

- **HEADER**: 0xAA (PC→MCU), 0xBB (MCU→PC)
- **LENGTH**: 数据长度 (0-252)
- **TYPE**: 命令类型
- **STATUS**: 状态码
- **DATA**: 可变长度数据
- **CHECKSUM**: ~(LENGTH + TYPE + STATUS + DATA各字节之和) & 0xFF

## 🚀 基础命令测试

### 1. 获取系统信息 (CMD_GET_INFO = 0x10)

**发送命令:**
```
AA 00 10 00 EF
```

**命令解析:**
- AA: PC→MCU头
- 00: 数据长度0
- 10: CMD_GET_INFO
- 00: STATUS_OK
- EF: 校验和 (~(0x00+0x10+0x00) = ~0x10 = 0xEF)

**预期响应:**
```
BB 14 01 00 [20字节系统信息] CS
```

**响应数据结构 (20字节):**
- firmware_version (4字节): 固件版本
- build_timestamp (4字节): 编译时间戳
- cpu_frequency (4字节): CPU频率
- device_id (2字节): 设备ID
- reset_reason (1字节): 复位原因
- boot_mode (1字节): 启动模式
- running_mode (1字节): 当前模式
- reserved (1字节): 保留字节

### 2. 获取内存信息 (CMD_GET_MEMORY = 0x11)

**发送命令:**
```
AA 00 11 00 EE
```

**命令解析:**
- AA: PC→MCU头
- 00: 数据长度0
- 11: CMD_GET_MEMORY
- 00: STATUS_OK
- EE: 校验和 (~(0x00+0x11+0x00) = ~0x11 = 0xEE)

**预期响应:**
```
BB 18 02 30 [24字节内存信息] CS
```

**响应数据结构 (24字节):**
- bootloader_start (4字节): 0x08000000
- bootloader_size (4字节): 0x00004000 (16KB)
- application_start (4字节): 0x08004000
- application_size (4字节): 0x0000C000 (48KB)
- ram_start (4字节): 0x20000000
- ram_size (4字节): 0x00005000 (20KB)
- page_size (2字节): 0x0400 (1024)
- page_count (1字节): 0x10 (16页)
- reserved (1字节): 0x00

### 3. 心跳包 (CMD_HEARTBEAT = 0x12)

**发送命令:**
```
AA 00 12 00 ED
```

**命令解析:**
- AA: PC→MCU头
- 00: 数据长度0
- 12: CMD_HEARTBEAT
- 00: STATUS_OK
- ED: 校验和 (~(0x00+0x12+0x00) = ~0x12 = 0xED)

**预期响应:**
```
BB 0C 03 01 [12字节状态报告] CS
```

**响应数据结构 (12字节):**
- uptime_ms (4字节): 运行时间
- last_command (2字节): 最后命令
- system_status (1字节): 系统状态
- error_count (1字节): 错误计数
- running_mode (1字节): 运行模式
- reserved (3字节): 保留字节

## 🔄 跳转命令测试

### 4. Bootloader → Application 跳转

**发送命令:**
```
AA 08 13 00 71 32 D0 07 78 56 34 12 56
```

**命令解析:**
- AA: PC→MCU头
- 08: 数据长度8字节
- 13: CMD_JUMP_TO_MODE
- 00: STATUS_OK
- 71: target_mode (MODE_APPLICATION = 0x71)
- 32: jump_delay_ms (50ms)
- D0 07: timeout_ms (2000ms, 小端序)
- 78 56 34 12: magic_word (0x12345678, 小端序)
- 56: 校验和

**校验和计算:**
```
SUM = 0x08 + 0x13 + 0x00 + 0x71 + 0x32 + 0xD0 + 0x07 + 0x78 + 0x56 + 0x34 + 0x12
    = 0x1A9
CHECKSUM = ~0xA9 = 0x56
```

**预期响应:**
```
BB 0C 05 52 [12字节跳转响应] CS
```

### 5. Application → Bootloader 跳转

**发送命令:**
```
AA 08 13 00 70 64 E8 03 78 56 34 12 57
```

**命令解析:**
- AA: PC→MCU头
- 08: 数据长度8字节
- 13: CMD_JUMP_TO_MODE
- 00: STATUS_OK
- 70: target_mode (MODE_BOOTLOADER = 0x70)
- 64: jump_delay_ms (100ms)
- E8 03: timeout_ms (1000ms, 小端序)
- 78 56 34 12: magic_word (0x12345678, 小端序)
- 57: 校验和

**校验和计算:**
```
SUM = 0x08 + 0x13 + 0x00 + 0x70 + 0x64 + 0xE8 + 0x03 + 0x78 + 0x56 + 0x34 + 0x12
    = 0x1A8
CHECKSUM = ~0xA8 = 0x57
```

**预期行为:**
- 立即响应跳转确认
- 延迟100ms后执行系统复位
- 重启进入bootloader模式

## 🧪 错误测试命令

### 6. 无效命令测试

**发送命令:**
```
AA 00 FF 00 00
```

**预期响应:**
```
BB 00 04 10 EF
```
- 04: CMD_ERROR_REPORT
- 10: ERROR_INVALID_CMD

### 7. 校验和错误测试

**发送命令:**
```
AA 00 10 00 00
```
(故意使用错误校验和)

**预期行为:**
- 无响应或错误响应

### 8. 无效跳转目标测试

**发送命令:**
```
AA 08 13 00 FF 32 D0 07 78 56 34 12 AB
```

**预期响应:**
```
BB 0C 05 56 [跳转错误响应] CS
```
- 05: CMD_JUMP_RESPONSE
- 56: MODE_INVALID_TARGET

### 9. 魔法字错误测试

**发送命令:**
```
AA 08 13 00 71 32 D0 07 12 34 56 78 AA
```

**预期响应:**
```
BB 0C 05 55 [跳转失败响应] CS
```
- 05: CMD_JUMP_RESPONSE
- 55: MODE_JUMP_FAILED

## 📊 状态码参考

### 系统状态 (0x00-0x0F)
- 0x00: STATUS_OK - 操作成功
- 0x01: STATUS_READY - 系统就绪
- 0x02: STATUS_BUSY - 系统忙碌
- 0x03: STATUS_IDLE - 系统空闲

### 错误状态 (0x10-0x2F)
- 0x10: ERROR_INVALID_CMD - 无效命令
- 0x11: ERROR_CHECKSUM - 校验和错误
- 0x12: ERROR_LENGTH - 长度错误
- 0x13: ERROR_TIMEOUT - 超时错误

### 内存状态 (0x30-0x4F)
- 0x30: MEM_BOOTLOADER_OK - Bootloader区域正常
- 0x31: MEM_APP_VALID - 应用程序有效
- 0x32: MEM_APP_INVALID - 应用程序无效
- 0x33: MEM_CONSTRAINT_OK - 内存约束检查通过
- 0x34: MEM_CONSTRAINT_ERR - 内存约束检查失败

### 跳转状态 (0x50-0x6F)
- 0x52: MODE_JUMP_REQUESTED - 跳转请求已接收
- 0x53: MODE_JUMP_PREPARING - 正在准备跳转
- 0x54: MODE_JUMP_SUCCESS - 跳转成功
- 0x55: MODE_JUMP_FAILED - 跳转失败
- 0x56: MODE_INVALID_TARGET - 无效目标模式
- 0x57: MODE_JUMP_TIMEOUT - 跳转超时

### 运行模式 (0x70-0x8F)
- 0x70: MODE_BOOTLOADER - Bootloader模式
- 0x71: MODE_APPLICATION - Application模式
- 0x72: MODE_SYSTEM_MEMORY - 系统内存模式
- 0x73: MODE_UNKNOWN - 未知模式

## 🔧 测试工具推荐

### 串口调试工具
1. **SSCOM** - 支持16进制发送
2. **Serial Port Utility** - 专业串口工具
3. **PuTTY** - 通用终端工具
4. **Tera Term** - 免费终端软件

### 自动化测试脚本
```python
import serial
import time

def send_command(ser, cmd_bytes):
    ser.write(cmd_bytes)
    time.sleep(0.1)
    response = ser.read_all()
    return response

# 测试系统信息
ser = serial.Serial('COM3', 115200)
response = send_command(ser, bytes([0xAA, 0x00, 0x10, 0x00, 0xEF]))
print(f"System Info: {response.hex()}")
```

## 📝 测试检查清单

### Bootloader模式测试
- [ ] 获取系统信息 (CMD_GET_INFO)
- [ ] 获取内存信息 (CMD_GET_MEMORY)
- [ ] 心跳包测试 (CMD_HEARTBEAT)
- [ ] 跳转到Application
- [ ] 10秒自动跳转验证

### Application模式测试
- [ ] 获取系统信息 (CMD_GET_INFO)
- [ ] 获取内存信息 (CMD_GET_MEMORY)
- [ ] 心跳包测试 (CMD_HEARTBEAT)
- [ ] 跳转到Bootloader
- [ ] LED闪烁功能验证

### 错误处理测试
- [ ] 无效命令响应
- [ ] 校验和错误处理
- [ ] 无效跳转目标
- [ ] 魔法字验证失败

### 压力测试
- [ ] 连续发送命令
- [ ] 快速跳转测试
- [ ] 长时间运行稳定性

## 🎯 快速验证步骤

1. **连接设备并打开串口工具**
2. **发送系统信息命令**: `AA 00 10 00 EF`
3. **验证响应格式**: `BB 14 01 00 [数据] CS`
4. **测试心跳包**: `AA 00 12 00 ED`
5. **测试跳转功能**: `AA 08 13 00 71 32 D0 07 78 56 34 12 56`
6. **验证跳转结果**: 检查模式切换是否成功

这份手册提供了完整的命令格式和测试流程，方便快速验证系统功能！