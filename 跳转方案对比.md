# 跳转方案对比说明

## 问题描述
App → Bootloader 跳转时，使用 `HAL_NVIC_SystemReset()` 软件复位方案，系统能收到跳转响应，但 bootloader 无法正常运行，串口无响应，需要手动按 RST 按键才能继续工作。

## 原因分析

### 软件复位的局限性
`HAL_NVIC_SystemReset()` 虽然能复位 CPU 内核，但存在以下问题：

1. **外设状态不完全复位** - 部分外设（如 UART、GPIO）可能保留配置状态
2. **时钟配置保留** - RCC 配置（HSE、PLL）可能不会恢复到默认状态
3. **启动顺序问题** - 复位后从当前地址重启，不一定从 bootloader 开始
4. **中断状态残留** - 某些中断挂起位可能未清除

### 硬件复位 vs 软件复位

| 特性 | 硬件复位 (RST按键) | 软件复位 (NVIC_SystemReset) |
|------|-------------------|----------------------------|
| CPU内核复位 | ✅ 完全复位 | ✅ 完全复位 |
| 外设复位 | ✅ 所有外设复位 | ⚠️ 部分外设可能保留状态 |
| 时钟复位 | ✅ 恢复到HSI | ⚠️ 可能保留HSE/PLL配置 |
| 中断清除 | ✅ 所有中断清除 | ⚠️ 需手动清除 |
| 启动地址 | ✅ 从0x08000000启动 | ⚠️ 取决于BOOT引脚和选项字节 |

## 解决方案：直接跳转法

参考 bootloader 的跳转实现，使用直接跳转而非软件复位：

### 核心步骤

```c
void Protocol_ResetToBootloader(void)
{
    typedef void (*pFunction)(void);
    pFunction jump_to_bootloader;
    uint32_t jump_address;
    
    // 1. 禁用所有中断
    __disable_irq();
    
    // 2. 禁用SysTick
    SysTick->CTRL = 0;
    SysTick->LOAD = 0;
    SysTick->VAL = 0;
    
    // 3. 清除所有挂起的中断
    for (int i = 0; i < 8; i++) {
        NVIC->ICPR[i] = 0xFFFFFFFF;
    }
    
    // 4. 复位所有外设
    __HAL_RCC_APB1_FORCE_RESET();
    __HAL_RCC_APB1_RELEASE_RESET();
    __HAL_RCC_APB2_FORCE_RESET();
    __HAL_RCC_APB2_RELEASE_RESET();
    
    // 5. 重置RCC到默认状态（HSI使能，HSE/PLL禁用）
    RCC->CR |= RCC_CR_HSION;
    while(!(RCC->CR & RCC_CR_HSIRDY));
    RCC->CFGR = 0x00000000;
    RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
    
    // 6. 重新映射中断向量表到bootloader地址
    SCB->VTOR = 0x08000000;
    
    // 7. 设置堆栈指针为bootloader的初始SP
    __set_MSP(*((volatile uint32_t*)0x08000000));
    
    // 8. 获取bootloader的Reset_Handler地址并跳转
    jump_address = *((volatile uint32_t*)(0x08000000 + 4));
    jump_to_bootloader = (pFunction)jump_address;
    jump_to_bootloader();
}
```

### 方案对比

| 操作 | 软件复位方案 | 直接跳转方案 |
|------|-------------|-------------|
| 中断禁用 | ✅ | ✅ |
| SysTick禁用 | ✅ | ✅ |
| 外设复位 | ❌ | ✅ (APB1/APB2强制复位) |
| 时钟复位 | ❌ | ✅ (切换回HSI) |
| 向量表重映射 | ✅ | ✅ |
| 堆栈指针设置 | ❌ | ✅ (设置为bootloader的SP) |
| 跳转方式 | NVIC_SystemReset() | 直接调用Reset_Handler |

## 技术细节

### 内存布局
- **Bootloader**: 0x08000000 - 0x08003FFF (16KB)
- **Application**: 0x08004000 - 0x0800FFFF (48KB)

### 向量表结构
```
地址            | 内容
----------------|------------------
0x08000000      | Initial Stack Pointer (MSP)
0x08000004      | Reset_Handler 地址
0x08000008      | NMI_Handler 地址
...             | 其他中断向量
```

### 跳转原理
1. **设置堆栈指针** - 从目标地址读取初始SP值，设置为新的主堆栈指针
2. **获取Reset_Handler** - 从目标地址+4读取复位处理程序地址
3. **直接跳转** - 通过函数指针直接调用Reset_Handler，就像系统复位一样启动

### 为什么直接跳转更可靠？
- 完全模拟硬件复位的启动流程
- 不依赖CPU复位机制，避免外设状态残留
- 手动清理所有系统状态，确保干净的启动环境
- 与bootloader跳转到app的方式对称，双向跳转逻辑一致

## 测试验证

### 测试命令
```bash
# Application → Bootloader (100ms延迟)
AA 08 13 00 70 64 E8 03 78 56 34 12 11
```

### 预期行为
1. ✅ App发送跳转确认响应: `BB 0C 05 52 ...`
2. ✅ 等待100ms后跳转到bootloader
3. ✅ Bootloader正常启动，UART可正常通信
4. ✅ 可以收到bootloader的系统信息响应

### 成功标志
- 无需手动按RST按键
- 跳转后bootloader串口立即可用
- 能正常接收并响应串口命令

## 最佳实践

1. **对称设计** - App→Bootloader和Bootloader→App使用相同的跳转机制
2. **彻底清理** - 跳转前完全重置外设和时钟状态
3. **正确顺序** - 先禁用中断，再复位外设，最后跳转
4. **堆栈正确性** - 必须正确设置目标程序的堆栈指针

## 参考文件

- `Core/Src/bootloader_jump.c` - Bootloader跳转实现（参考模板）
- `app/Core/Src/protocol.c` - Application跳转实现
- `Core/Inc/bootloader_jump.h` - 跳转函数声明

---
**总结**: 软件复位在某些情况下无法达到硬件复位的效果，直接跳转方案通过手动清理系统状态并模拟启动流程，可以实现可靠的程序间跳转。
