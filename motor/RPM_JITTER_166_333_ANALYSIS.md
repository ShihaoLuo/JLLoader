# RPM跳变问题分析 (166/333跳变)

## 问题症状

```
目标RPM: 200
实际RPM显示: 166 ↔ 333 (不断跳变)
现象: RPM显示不稳定，在166和333之间切换
```

---

## 根本原因分析

### 1. RPM计算公式回顾

```c
RPM = (pulse_count × 3000) / PPR
    = (pulse_count × 3000) / 18
```

其中：
- `pulse_count`: 每20ms内检测到的脉冲数
- `3000 = 60秒/分钟 × 50次/秒` (20ms周期)
- `PPR = 18` (每转18个脉冲)

### 2. 发现的规律

```
显示166 RPM时:
  166 = (pulse_count × 3000) / 18
  pulse_count = (166 × 18) / 3000 = 1.0 ✓

显示333 RPM时:
  333 = (pulse_count × 3000) / 18
  pulse_count = (333 × 18) / 3000 = 2.0 ✓
```

**结论**：
- 当20ms内脉冲数 = 1时 → RPM = 166
- 当20ms内脉冲数 = 2时 → RPM = 333
- 当20ms内脉冲数 = 0时 → RPM = 0

---

## 问题所在

### 脉冲频率与周期的不匹配

根据前面的测量：**脉冲频率 = 120-140 Hz**

```
120 Hz → 20ms内脉冲数 = 120 Hz ÷ 50 Hz = 2.4个脉冲
140 Hz → 20ms内脉冲数 = 140 Hz ÷ 50 Hz = 2.8个脉冲

但由于pulse_count是整数：
- 有时会计到1个脉冲
- 有时会计到2个脉冲
- 有时会计到3个脉冲
```

### 为什么会跳变？

```
第1个20ms周期: pulse_count = 1 → RPM = 166 ✓
  (实际脉冲落在前面)

第2个20ms周期: pulse_count = 2 → RPM = 333 ✓
  (实际脉冲落在中间)

第3个20ms周期: pulse_count = 1 → RPM = 166 ✓
  (实际脉冲又落在前面)
```

**原因**：脉冲周期(1/120-140Hz ≈ 7-8ms)接近但不是20ms的整数倍

```
脉冲周期: ~7.14ms (120Hz)
检测周期: 20ms (50Hz)

LCM(7.14, 20) = 142.8ms

这意味着每~143ms脉冲会与20ms检测周期重新对齐
```

---

## 解决方案

### 方案1: 延长检测周期 (推荐 ✓)

将RPM更新周期从20ms改为100ms或1000ms，可以计算更多脉冲：

```c
// 修改前：每20ms更新一次 (50Hz)
// 修改后：每100ms更新一次 (10Hz)

100ms内脉冲数 = 120-140 Hz × 0.1s = 12-14个脉冲
RPM = (12-14 × 3000) / 18 = 2000-2333 RPM

问题: 这会导致RPM数值太大（不符合目标200RPM）
```

**重新计算**：

```
目标200RPM → 需要的脉冲数 = (200 × 18) / 3000 = 1.2个脉冲/20ms

这太小了！问题在于：
- 目标RPM太低 (200 RPM)
- 脉冲频率太高 (120-140 Hz)
- 检测周期太短 (20ms)
```

### 方案2: 修改PPR或频率参考

实际上，**目标RPM和实际脉冲频率不匹配**：

```
从120-140Hz脉冲频率反推：
  120 Hz ÷ 18 PPR = 6.67转/秒 = 400 RPM
  140 Hz ÷ 18 PPR = 7.78转/秒 = 467 RPM

预期目标: 200 RPM → 需要 60-70 Hz 的脉冲
实际脉冲: 120-140 Hz → 对应 400-467 RPM
```

**发现的真实问题**：
1. 脉冲频率是200RPM的2倍（120-140Hz vs 60-70Hz）
2. 要么是PPR错误（应该是36不是18）
3. 要么是目标RPM设置错误

### 方案3: 改进的RPM计算方法 (实时修复)

在不改变周期的情况下，使用**累积脉冲计数**代替每个周期都重置：

```c
// 旧方法（不稳定）
每20ms重置一次pulse_count

// 新方法（平滑）
// 保留多个周期的脉冲计数，计算平均值
#define RPM_FILTER_SIZE 5
uint32_t pulse_history[5];
uint8_t history_index = 0;

void Motor_RPM_Detection_Update(void)
{
  // 保存当前脉冲计数
  pulse_history[history_index] = pulse_count;
  history_index = (history_index + 1) % RPM_FILTER_SIZE;
  
  // 计算5个周期的平均脉冲数
  uint32_t total_pulses = 0;
  for(int i = 0; i < RPM_FILTER_SIZE; i++) {
    total_pulses += pulse_history[i];
  }
  uint32_t avg_pulses = total_pulses / RPM_FILTER_SIZE;
  
  // 使用平均值计算RPM
  motor_rpm = (avg_pulses * 3000) / 18;
  
  pulse_count = 0;
}
```

---

## 诊断建议

### 1. 验证脉冲频率与目标RPM的对应关系

```
当前脉冲: 120-140 Hz
PPR = 18

实际转速 = (频率 × 60) / PPR
         = (120-140 × 60) / 18
         = 400-467 RPM

问题: 这与目标200RPM不符!
```

**需要确认**：
- [ ] 目标RPM是否正确设置？
- [ ] PPR=18是否正确？
- [ ] 脉冲信号是否被计数了两次？

### 2. 验证目标RPM的真实含义

如果目标RPM是200，应该需要：
```
脉冲频率 = (200 RPM × 18 PPR) / 60 = 60 Hz
```

**但实际脉冲是120-140Hz，说明**：
1. ✓ 脉冲频率是预期的2倍，可能PPR应该是36
2. ✗ 或者脉冲被计数了2次
3. ✗ 或者目标RPM应该是400-467

---

## 推荐修复步骤

### 第一步: 确认PPR值

检查实际的脉冲信号：
- 一个转周期有多少个脉冲？
- 是否PPR应该是36而不是18？

```c
// 临时修改用于测试
// #define PPR 18  // 旧
#define PPR 36  // 新的测试值

if(PPR == 36):
  RPM = (120-140 Hz × 60) / 36 = 200-233 RPM ✓
```

### 第二步: 修改RPM计算周期或使用滤波

如果PPR确实是18，需要改进RPM检测方法

### 第三步: 验证脉冲是否被正确计数

确保没有重复计数或干扰

---

## 快速对比表

| 参数 | 当前值 | 计算结果 | 预期目标 |
|------|--------|---------|---------|
| 脉冲频率 | 120-140 Hz | - | 60 Hz (for 200RPM) |
| PPR | 18 | - | ? |
| 计算周期 | 20ms | - | ? |
| 转速(120Hz) | 120Hz | 400RPM | 200RPM ✗ |
| 转速(140Hz) | 140Hz | 467RPM | 200RPM ✗ |

**关键问题**: 脉冲频率是目标转速的2倍！

