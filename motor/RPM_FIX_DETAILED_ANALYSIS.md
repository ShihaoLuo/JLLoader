# RPM计算修复 - 详细对比

## 问题根源

之前的优化设计存在**逻辑缺口**：

```
设计意图：
- 100ms时间窗口采样
- 使用公式: RPM = (脉冲数 × 600) / 18

实现错误：
- RPM_UPDATE_DIVIDER = 2  (只相当于10ms，不是100ms!)
- RPM_FILTER_SIZE = 2      (只覆盖20ms，不是100ms!)
- 结果：脉冲数被当做100ms采样，但实际只采了10ms
- 导致：RPM显示为实际的1/10

具体问题在于：
分频比2 × 5ms = 10ms
但公式按100ms编写
缺口 = 100ms / 10ms = 10倍！
```

## 详细修复

### 错误参数组合 ❌

```c
// motor_ctrl.c (旧)
#define RPM_UPDATE_DIVIDER 2
// → 调用间隔: 2 × 5ms = 10ms ❌

// motor_ctrl.h (旧)
#define RPM_FILTER_SIZE 2
// → 历史窗口: 2 × 10ms = 20ms ❌

// motor_ctrl.c (旧)
float rpm_smooth_calc = (float)avg_pulses * 600.0f / 18.0f;
// → 公式按100ms编写 ❌
// 但实际只有10ms采样 ❌
// 结果: RPM = 脉冲数 × 600 / 18
//      应该: RPM = 脉冲数 × 6000 / 18
//      偏差: 1/10 ❌
```

### 正确参数组合 ✅

```c
// motor_ctrl.c (新)
#define RPM_UPDATE_DIVIDER 20
// → 调用间隔: 20 × 5ms = 100ms ✓

// motor_ctrl.h (新)
#define RPM_FILTER_SIZE 10
// → 历史窗口: 10 × 100ms = 1000ms ✓

// motor_ctrl.c (新)
float rpm_smooth_calc = (float)avg_pulses * 600.0f / 18.0f;
// → 公式按100ms编写 ✓
// 实际采样周期: 100ms ✓
// 结果: RPM = 脉冲数 × 600 / 18 = 正确 ✓
```

## 计算精度验证

### 案例1: 1000 RPM

```
脉冲频率 = 1000 × 18 / 60 = 300 Hz

修复前 (错误):
├─ 采样周期: 10ms (分频2×5ms)
├─ 周期脉冲数: 300 × 0.01 = 3个
├─ 公式: 3 × 600 / 18 = 100
├─ 显示: 100 RPM
└─ 实际: 1000 RPM
    差异: 1/10 ❌

修复后 (正确):
├─ 采样周期: 100ms (分频20×5ms)  
├─ 周期脉冲数: 300 × 0.1 = 30个
├─ 公式: 30 × 600 / 18 = 1000
├─ 显示: 1000 RPM
└─ 实际: 1000 RPM
    差异: 完美 ✓
```

### 案例2: 2500 RPM

```
脉冲频率 = 2500 × 18 / 60 = 750 Hz

修复前 (错误):
├─ 10ms采样: 750 × 0.01 = 7.5 ≈ 7-8个
├─ 脉冲数7: 7 × 600 / 18 = 233 RPM ❌
├─ 脉冲数8: 8 × 600 / 18 = 267 RPM ❌
└─ 实际应该: 2500 RPM

修复后 (正确):
├─ 100ms采样: 750 × 0.1 = 75个
├─ 公式: 75 × 600 / 18 = 2500 RPM ✓
└─ 精度: ±1脉冲 = ±33.3 RPM (1.3%)
```

### 案例3: 4100 RPM (最大转速)

```
脉冲频率 = 4100 × 18 / 60 = 1230 Hz

修复前 (错误):
├─ 10ms采样: 1230 × 0.01 = 12.3 ≈ 12个
├─ 计算: 12 × 600 / 18 = 400 RPM ❌❌❌
├─ 显示: 410 RPM (严重不足!)
└─ 实际: 4100 RPM
    差异: 1/10 + 量化误差

修复后 (正确):
├─ 100ms采样: 1230 × 0.1 = 123个
├─ 计算: 123 × 600 / 18 = 4100 RPM ✓
├─ 显示: 4100 RPM
└─ 精度: ±0.4% (非常好!)
```

## 时间窗口对比

### 修复前 (20ms窗口)

```
时间轴：
0ms       10ms      20ms      30ms      40ms
|---------|---------|---------|---------|
RPM_Det   RPM_Det   RPM_Det   RPM_Det   
 ^        ^         ^         ^
 采样     采样      采样      采样
 只有10ms覆盖
 
公式用的是100ms系数 → 结果1/10
```

### 修复后 (100ms窗口)

```
时间轴：
0ms       50ms      100ms     150ms     200ms
|---------|---------|---------|---------|
RPM_Det                       RPM_Det
^                             ^
采样100ms                    采样100ms

历史缓存 (1000ms):
|---------|---------|---------|---------|---------|---------|---------|---------|---------|---------|
 100ms     100ms     100ms     100ms     100ms     100ms     100ms     100ms     100ms     100ms
 周期1     周期2     周期3     周期4     周期5     周期6     周期7     周期8     周期9     周期10

平均转速 = (周期1+2+...+10的脉冲数) × 600 / 18 / 10

→ 非常平滑可靠 ✓
```

## 实际影响分析

### 系统的症状变化

**修复前:**
- 显示的转速: 实际的1/10
- 例: 设置2400 RPM → 显示240 RPM
- 电机: 可能完全不动 (PWM不足)
- 或者: 全速运转但显示值错误

**修复后:**
- 显示的转速: 准确的
- 例: 设置2400 RPM → 显示2400 RPM
- 电机: 正常运行在目标转速
- PID: 能正确调节

### 对PID控制的影响

**修复前:**
```
PID误差 = 目标2400 - 读取值240 = 2160 RPM ❌
→ PID输出巨大
→ PWM直接拉满或饱和
→ 控制无法精细调节
→ 系统可能失控
```

**修复后:**
```
PID误差 = 目标2400 - 读取值2400 = 0 RPM ✓
→ PID输出合理
→ PWM精细调节
→ 控制稳定可靠
→ 系统正常工作
```

## 修改前后的代码对比

### motor_ctrl.c (全局变量区)

```diff
  // 频率分频计数器
  static uint8_t tim2_interrupt_counter = 0;
- #define RPM_UPDATE_DIVIDER 2   // 每2个中断
- #define PID_UPDATE_DIVIDER 1   // 每1个中断
+ #define RPM_UPDATE_DIVIDER 20  // 每20个中断 = 100ms
+ #define PID_UPDATE_DIVIDER 1   // 每1个中断 = 5ms
```

### motor_ctrl.h (参数定义)

```diff
  // RPM检测平滑滤波参数
- #define RPM_FILTER_SIZE 2              // 2个周期 = 20ms
- #define RPM_DETECTION_PERIOD_MS 100
+ #define RPM_FILTER_SIZE 10             // 10个周期 = 1000ms
+ #define RPM_DETECTION_PERIOD_MS 100    // 真实周期100ms
```

### motor_ctrl.c (函数注释)

```diff
  /**
-  * @brief  更新RPM检测（定时器中断中调用，100Hz/10ms）
+  * @brief  更新RPM检测（定时器中断中调用，10Hz/100ms）
   * @retval None
   */
  void Motor_RPM_Detection_Update(void)
  {
    if (!rpm_detection_active) return;
    
    rpm_update_count++;
    
-   /* 每10ms更新一次转速计算（频率法，100Hz更新）
-    * 时间窗口：100ms (10个5ms周期，其中2个周期取样)
-    * 公式调整：原来20ms周期用 × 3000/18，现在100ms周期用 × 600/18
-    * = (脉冲数 × 600) / 18 = (脉冲数 × 33.33)
+   /* RPM计算说明（10Hz更新，100ms周期）
+    * 中断分频: 200Hz ÷ 20 = 10Hz
+    * 每个RPM_Detection_Update调用间隔: 100ms
+    * 
+    * RPM计算公式：
+    * RPM = (脉冲数 × 60) / (PPR × 时间秒数)
+    *     = (脉冲数 × 60) / (18 × 0.1)  [时间=100ms=0.1秒]
+    *     = (脉冲数 × 60) / 1.8
+    *     = (脉冲数 × 600) / 18
+    * 
+    * 验证：4100 RPM目标
+    * 脉冲频率 = 4100 × 18 / 60 = 1230 Hz
+    * 100ms内脉冲数 = 1230 × 0.1 = 123个
+    * RPM = 123 × 600 / 18 = 4100 ✓
     */
```

## 测试验证清单

- [ ] 编译无错误
- [ ] 设置RPM 1000，等待300ms，检查motor_rpm ≈ 1000
- [ ] 设置RPM 2000，检查motor_rpm ≈ 2000 (不是200!)
- [ ] 设置RPM 3000，检查转速曲线平滑
- [ ] 设置RPM 4100，检查是否能达到最大转速
- [ ] 观察rpm_update_count增速 (应该以10Hz增加)
- [ ] 用示波器验证PB0脉冲频率 ≈ RPM × 18 / 60

## 总结

| 指标 | 修复前 | 修复后 |
|------|-------|-------|
| **RPM显示准确度** | 1/10 (严重错误) | 准确 ✓ |
| **采样周期** | 10ms ❌ | 100ms ✓ |
| **采样公式** | 600系数但只10ms采样 ❌ | 600系数且100ms采样 ✓ |
| **历史窗口** | 20ms ❌ | 1000ms ✓ |
| **PID控制** | 基于错误反馈，失效 | 基于准确反馈，正常 |
| **电机表现** | 可能不动或失控 | 正常平稳运行 |

---

**这是一个严重的系统级错误，修复后系统才能正常工作！**

